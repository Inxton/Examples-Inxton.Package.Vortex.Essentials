![Inxton logo](./assets/logo.png)

Nowadays Programmable Logic Controllers (PLC) are required to do more than ever before:  access databases, make HTTP requests, build JSONs - stuff they were never meant to do. Even though it's possible, the PLC code is repetitive and hard to navigate, forcing the programmers to spend too much time fixing errors instead of focusing on improvements.
 
Thanks to Inxton.Vortex.Framework, you can use a high-level programming language like C# to make your solutions more efficient and easier to operate. **Use the PLC for what it was designed to do and leave all the advanced problems to a modern environment like .NET**.

# About sample projects

These examples aim to present the use and capabilities of *Inxton.Package.Vortex.Core*. It is a basic yet powerful set of tools that allow you to interact with Beckhoff TwinCAT3 PLC data from .NET (e.g. C#, VB, etc) in a fast and scalable way. This package is part of *Inxton.Vortex.Framework*.

![tc3-inxton-future.png](./assets/tc3-inxton-future.png)

## Compiler

*Inxton.Vortex.Compiler* is the founding block of the Inxton.Vortex.Framework. It creates one-to-one C# objects from the TwinCAT 3 PLC program so that you can access the PLC data in any .NET based platform.

TwinCAT 3 project that contains ```HansPlc``` program that will be translated into a .NET project called ```HansPlcConnector```. This is the bridge between TwinCAT 3 PLC and .NET.

`HansPlcConnector` contains `TwinObjects` - a .NET representation of a complex PLC data type (STRUCT, UNION, FB, GVL, PRG). Each of these data structures is represented by a standalone C# class with the same name and attributes as its PLC counterpart. The root class representing the `HansPlc` (the actual PLC project) is `HansPlcTwinController`.

![inxton_transpile.gif](./assets/inxton_transpile.gif)

Learn more about the compiler [here](https://github.com/Inxton/Inxton.Package.Vortex.Core/blob/master/Inxton.vortex.compiler.console/README.md).

Learn more about the `TwinObject` [here](https://github.com/Inxton/Inxton.Package.Vortex.Core/blob/master/Inxton.vortex.compiler.console/Conceptual/TwinObjects.md)

## Accessing the PLC data

Autogenerated code in `HansPlcConnector` project gives you structured access to PLC data in various forms via `TwinObject`. This object contains respective primitive variables as `TwinPrimitive`(s) and can also have other `TwinObject`(s) of its PLC counterpart nested in it. The default entry point to the twin objects of the PLC program is the [TwinController](https://github.com/Inxton/Inxton.Package.Vortex.Core/blob/master/Inxton.vortex.compiler.console/Conceptual/TwinController.md) object.

Each `TwinObject` implements `IOnline` and `IShadow` interfaces to access its `TwinPrimitives` and  `TwinObjects`.

- `IOnline` interface which exposes members with direct communication ability with the PLC system.
    - **Cyclic access** - a two-way access to the PLC variables. Cyclic values are being read and written in an optimized periodic loop.
    - **Synchronous access** - an immediate two-way access to the PLC variable.

 - `IShadow` interface allows for offline manipulation of the object's data.

There is a separate class Plainer, that is produced during the transpiling process, which is a light (POCO like) representation of the same data structure. It can be used in scenarios involving serialization.

![onliner-shadow-plain.png](./assets/onliner-shadow-plain.png)

Watch video about Data flow in Inxton [here](https://youtu.be/BU-ggYRUCXc)

Learn more about `TwinPrimitives` [here](https://github.com/Inxton/Inxton.Package.Vortex.Core/blob/master/Inxton.Vortex.Connector/Conceptual/PrimitiveTwins.md).

# Getting started

## Check the prerequisites

Make sure you have everything you need to start using examples in this repository [here](https://github.com/Inxton/Inxton.Package.Vortex.Core/blob/master/PREREQUISITES.MD).

## Clone this repository

~~~ bash
git clone https://github.com/Inxton/Examples-Inxton.Package.Vortex.Core.git
~~~

Or download the zip file [here](https://bit.ly/2UVGnNb)

## Open the solution

 ```Inxton.Vortex.Core.Examples.sln ```

Once you open the solution, you will see a XAE project that contains ```HansPlc``` project. ```HansPlc``` project has its .NET Twin project called ```HansPlcConnector```. These two projects constitute the starting point for all subsequent examples.

## Restore packages

Open Nuget manage for the solution and restore the missing packages.
![update_packages](./assets/update_packages.gif)

## Update Packages
In case you have any problems with NuGet :
Open *Package Manager Console* and type:
~~~PowerShell
Update-Package -Reinstall
~~~

## Activate the configuration

Activate your configuration, download the PLC to your target system, and run it as any other TwinCAT 3 project. You will need to set the target system to the target you have available (e.g. local).

Follow the instructions from [Beckhoff - Activating a TwinCAT 3 project
](https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_plc_intro/36028799544005771.html&id=)

## Copy the license file
To run your Inxton application you need to have a valid licence. The preview licence file is provided completely free of charge.

The installation is simple, just follow these steps:
1. Dowload **License.xml** file from GitHub [here](http://bit.ly/future_of_automation) or in raw format [here](https://bit.ly/2w8nFbT).
2. Don't forget to save the license as **.xml** file.
3. Copy/Move license into `C:\Inxton\License.xml` folder.

> **Note:** *Preview license is valid until 2020-SEPT-01. Don't worry, you will be fine, the full release is coming out in July 2020.*

## Connect your app to your PLC

Let's start a simple PLC project - a counter.
~~~PASCAL
PROGRAM prgSimple
VAR
    _counter : ULINT;
    _counterActive : BOOL;
END_VAR
~~~
Run the program in the PLC main loop.
~~~PASCAL
PROGRAM MAIN
---
prgSimple();
~~~

You will need to set up *AMS ID* and *port* (if changed for some reason). Open file ```../HansPlcConnector/Entry.cs```

~~~ C#
#define LOCAL // Comment if your target is remote

using Vortex.Adapters.Connector.Tc3.Adapter;

namespace HansPlc
{
    public static class Entry
    {
#if LOCAL
        const string AmsId = null; // your ams id or set to 'null' if local
        const int Port = 851;
#else
        const string AmsId = "172.20.10.102.1.1"; // set your target ams id
        const int Port = 851;
#endif
        public static HansPlcTwinController HansPlc { get; } = new HansPlcTwinController(Tc3ConnectorAdapter.Create(AmsId, Port));
    }
}
~~~

Let's establish a connection between the PLC and your .NET app.
~~~c#
var hans = HansPlc.Entry.HansPlc;
hans.Connector.BuildAndStart();
~~~

Access to the PLC variables from C# is very simple thanks to `TwinObject` and IntelliSense
 
Write to PLC variable from C#.
~~~C#
var simple = hans.prgSimple; // this is how you access the program
simple._counterActive.Synchron = true;
simple._counter.Cyclic = 132;
~~~

Read PLC variable using C#
~~~C#
var currentCount = simple._counter.Synchron;
if(currentCount > 133)
{
    Console.WriteLine($"Current count is way too high! it's {currentCount}");
}
~~~

> NOTE: Each property provides access to a variable via Synchron and Cyclic.

## Examples

### [Simple](Simple/README.MD)

*Simple* examples have a rudimentary PLC counter. We aimed to show basic manipulation with twins of the PLC. Accessing variables, reading, writing, displaying (WPF, and WinForms).

`Onliner` implements `INotifyPropertyChanged` therefore binding works as with any other property.

~~~xml
<TextBlock Text="{Binding _counter.Cyclic}" />
~~~

> REMARKS: It is possible to use WinForms to create valuable applications. WinForm offers a simple approach and you might be more familiar with the technology. On the other hand, it requires more manual coding. If you want to get the best from the framework, consider starting with WPF. WPF offers very powerful data binding, styling, templates, and effective work with components. Be aware that WPF usually has a steep learning curve. It is, however, worth the effort.

![Inxton logo](./assets/SimpleCounter.gif)

### [AddedProperties](./AddedProperties/README.MD)

This example is trying to present a feature that allows you to introduce additional properties to twin objects in the PLC code.

Define a simple function block with two variables and use pragma `attribute addProperty` to decorate variables with additional attributes `Name` and `Units`.

~~~PASCAL
FUNCTION_BLOCK fbDrive
VAR
    {attribute addProperty Name "Position"}
    {attribute addProperty Units "mm"}  
    Position : LREAL;
    
    {attribute addProperty Name "Speed"}
    {attribute addProperty Units "mm/s"}
    Speed : LREAL;
END_VAR
~~~

Create an instance of the function block and add an attribute name.

~~~PASCAL
PROGRAM prgAddedProperties
VAR
    {attribute addProperty Name "Drive X"}
    fbDriveX : fbDrive;
END_VAR
---
fbDriveX();
~~~

Access added properties from C#.

~~~C#
var program = hans.prgAddedProperties;
var driveName = program.fbDriveX.AttributeName;  // Drive X
var drivePosition = program.fbDriveX.Position.Synchron;
var drivePositionUnits = program.fbDriveX.Position.AttributeUnits; // mm

var driveSpeed = program.fbDriveX.Speed.Cyclic;
var driveSpeedUnits = program.fbDriveX.Speed.AttributeUnits; // mm/s
               
Console.WriteLine($"{driveName} is at position {drivePosition} {drivePositionUnits} and  moving at speed {driveSpeed} {driveSpeedUnits}"); 
~~~
![Inxton logo](./assets/addedPropertyUse1.png)
### [Weather stations](./WeatherStations/README.MD)

In this example, we are showing the ease with which you can use the power of .NET ecosystem with the PLC. We are reading the data from some weather stations from around the world (via .NET library) and we pass the data to the PLC. The PLC then makes its own statements about the weather situation in different parts of the world.

The console application shows different ways to access PLCs' variables (Cyclical, Synchronous, Batched). There are descriptive comments in the code that should help you grasp basic concepts.

This project also demonstrates the ability to localize PLC strings in an easy and straightforward way. The framework takes care of translating PLC STRING, WSTRING at runtime using applications' resources. Notice that localizable PLC strings are enclosed between <# and #>.
![Inxton logo](./assets/weather_wpf.png)

# Need help?

🧪 Create an issue [here](https://github.com/Inxton/Feedback/issues/new/choose)

📫 We use mail, too: team@inxton.com

🐤 Contact us on Twitter [@Inxton](https://twitter.com/inxtonteam)

📽 Check out our [YouTube](https://www.youtube.com/channel/UCB3EcnWyLSsV5gqSt8PRDXA/featured)

🌐 For more info check out our website [INXTON.com](https://www.inxton.com/)


# Contributing

We are more than happy to hear your feedback and ideas!
Just submit it [here](https://github.com/Inxton/Feedback/issues/new/choose)  


# License

TLDR
> You can use Inxton.Vortex.Framework free of charge, although when you want to use it in a production environment you need to go to  [INXTON.com](https://www.inxton.com/) and purchase a license.

To make our lawyers happy - read the whole license agreement [here](https://github.com/Inxton/about/blob/master/license.md)


## What to do next?

Check out the documentation  [Inxton.Package.Vortex.Core](https://github.com/Inxton/Inxton.Package.Vortex.Core)

Install the extension from [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=Inxton.InxtonVortexBuilderExtensionPre)


---
Developed with ♥ at [MTS](https://www.mts.sk/en) - putting the heart into manufacturing.
 
